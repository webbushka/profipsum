{
  "name": "nodeject",
  "version": "0.2.1",
  "description": "A simple dependency injection module for JavaScript.  Works as both a node.js module and as a browser module.  CommonJS compatible.",
  "author": {
    "name": "James White",
    "email": "james@llamasantos.com"
  },
  "main": "./lib/index.js",
  "keywords": [
    "DI",
    "Dependency",
    "Injection",
    "Simple"
  ],
  "devDependencies": {
    "mocha": "*"
  },
  "engines": {
    "node": ">=0.8.*"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "license": "MIT",
  "readme": "#Usage\r\n\r\nThe container is simple.  You use define and resolve to manage all dependencies.\r\n\r\n[![Build Status](https://travis-ci.org/LlamaSantos/Nodeject.png?branch=master)](https://travis-ci.org/LlamaSantos/Nodeject)\r\n\r\n##Todo\r\n- Cyclical dependency detection.\r\n- Better lifetime management, singleton flag is nice, but there are more than just transient and singleton lifetimes.\r\n- Browser script to be used in AMD/CommonJS/POJS(Plain Old Javascript).\r\n\r\n###Example\r\n```JavaScript\r\nvar container = new Nodeject();\r\n\r\ncontainer.define({ name : \"module1\", type : require(\"module1\") })\r\n         .define({ name : \"module2\", type : require(\"module2\"), deps: [\"module1\"] });\r\n\r\n var module2Impl = container.resolve(\"module2\");\r\n```\r\n\r\n###define\r\n```JavaScript\r\n//Uses the options pattern to configure an entity.\r\nfunction define(options) { ... };\r\n\r\ncontainer.define({\r\n        name : \"module1\",           // Must be a unique name in the container.\r\n        type : MyType,              // Can be a Prototype, Power Constructor, String, or Array\r\n        deps : [\"module2\", \"m2\"],   // Array of modules configured or to be configured in the container.\r\n        singleton : false           // If a singleton is needed, pass true, default is false.\r\n    });\r\n\r\n```\r\n\r\n\r\n\r\n###resolve\r\n```JavaScript\r\n// Resolves with a single module name.\r\nfunction resolve(moduleName) { ... };\r\n\r\nvar module1 = container.resolve(\"moduleName\");\r\n```\r\n\r\n###categories\r\nCategories are a way of configuring multiple items and resolving them under a single name.  This is helpful when configuring\r\ncontrollers or presenters where initialization needs to occur in bulk.\r\n```JavaScript\r\n// Configure the container with entities having a common category\r\ncontainer.define({\r\n    name : \"module1\",\r\n    type : MyType,\r\n    category : \"category1\"\r\n})\r\n.define({\r\n    name : \"module2\",\r\n    type : MyOtherType,\r\n    category : \"category1\"\r\n})\r\n\r\nvar entities = container.resolve({ category : \"category1\" });\r\nassert.ok (entities[0] instanceof MyType);          // asserts true\r\nassert.ok (entities[1] instanceof MyOtherType);     // asserts true\r\n\r\nvar entities = container.resolve({ category : \"category1\", format : \"literal\" });\r\nassert.ok (\"module1\" in entities);                  // asserts true\r\nassert.ok (\"module2\" in entities);                  // asserts true\r\n```\r\n",
  "readmeFilename": "readme.md",
  "_id": "nodeject@0.2.1",
  "_from": "nodeject@*"
}
